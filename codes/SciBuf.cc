//scibuf.cc
//Lab4
//Jin Won Seo

#include "SciBuf.h"

SciBuf::SciBuf(size_t rxLen, size_t txLen)
:rxBuf(new char[rxLen]), rxEnd(rxBuf+rxLen), txBuf(new char[txLen]), txEnd(txBuf+txLen)
{
	setg(rxBuf, rxEnd, rxEnd);//rxBuf empty
	setp(txBuf, txEnd);//txBuf is nothing there
}

SciBuf::~SciBuf()
{
	delete[] rxBuf;
	delete[] txBuf;
}

/*
* write output buffer to device
* reset buffer(txBuffer0, setp(beg,end)
*/
int SciBuf::sync()
{
	for(char* p=pbase(); p<pptr(); p++)
		send(*p);
	setp(txBuf, txEnd);
	return 0;
}
/*
* this is for when buffer is full but there is one char needs to get in buffer
* call sync() to empty buffer(txBuffer)
* deal with one more char
*/
int SciBuf::overflow(int c)
{
	sync();
	sputc(c);//put c in buffer
	return 0;
}

/*
* fill buffer(rxBuffer) from device
* set up pointers to buffer, setg(beg,beg,end)
*/
int SciBuf::underflow()
{
	char* p(rxBuf);
	do{
		*p++ = recv();
	}while(p < rxEnd && avail());
	
	setg(rxBuf,rxBuf,p);//reset
	return (rxBuf[0]);
}
//it's system dependent pure virtual func
//It seems to be against polymorphism... howerever, it works anyhow.
//error handler that this fucntion may be called others, so this function generated by compiler must be defined.
extern "C" int __pure_virtual(void) {
	while(1);
}
	
